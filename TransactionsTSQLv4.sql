-- Свойства транзакций ACID:

-- Атомарность (atomicity). Каждая транзакция является атомарной единицей работы. 
-- Это означает, что в транзакции либо выполняются все изменения базы
-- данных, либо ни одно из них.

-- Согласованность (consistency). Каждая транзакция, как завершившаяся, так и
-- прерванная, оставляет базу данных в согласованном состоянии, как определяет-
-- ся всеми ограничениями объектов и базы данных. При возникновении несогла-
-- сованного состояния SQL Server выполнит откат транзакции, чтобы поддержать
-- согласованное состояние.

-- Изоляция (isolation). Каждая транзакция выполняется так, как будто она суще-
-- ствует в изоляции от всех остальных транзакций по отношению к изменениям в
-- базе данных. Степень изолированности может меняться в зависимоси от уровня
-- изоляции.

-- Устойчивость (durability). Каждая транзакция претерпевает прерывание серви-
-- са. Когда сервис восстанавливается, все зафиксированные (committed) транзак-
-- ции накатываются (зафиксированные изменения в базе данных завершены), а
-- все нефиксированные транзакции откатываются (нефиксированные изменения
-- удаляются).






-- Функцию @@TRANCOUNT можно запросить для того, чтобы узнать уровень вложенности транзакции. 
-- Уровень, равный 0, указывает, что в данный момент код находится не внутри
-- транзакции.
-- Уровень больше 0 указывает, что транзакция активна, при этом если значение
-- больше 1, то оно указывает уровень вложенности для вложенных транзакций.

-- Функцию XACT_STATE() можно запросить для определения состояния транзакции.
-- Состояние, равное 0, указывает на то, что это неактивная транзакция.
-- Состояние, равное 1, указывает, что это незафиксированная транзакция, которая может быть зафиксирована, но не известен уровень ее вложенности.
-- Состояние, равное –1, указывает, что имеется незафиксированная транзакция,
-- но она не может быть зафиксирована из-за предшествующей фатальной ошибки. 

-- Режимы транзакций:

--  автофиксация (autocommit);                 Режим по умолчанию. Любые изменения в базе данных обрабатываются автоматически, инструкция за инструкцией, как транзакции

--  неявная транзакция (implicit transaction); Перейти в этот режим: SET IMPLICIT_TRANSACTIONS ON; 
                                            -- Как только вы вводите какую-либо команду для изменения данных, значение
                                            -- @@TRANCOUNT становится равным 1, указывая, что вы находитесь на первом уровне вложенности транзакции. Затем необходимо вручную запустить команду COMMIT
                                            -- или ROLLBACK для завершения транзакции. Если вы запустите дополнительные инструкции DML или DDL, они также станут частью этой транзакции. 

--  явная транзакция (explicit transaction).   Явная транзакция выполняется, если для запуска транзакции явно указана команда BEGIN TRANSACTION или BEGIN TRAN.
                                            -- Как только вы запускаете команду BEGIN TRAN, значение @@TRANCOUNT увеличивается на 1.
                                            -- Затем вы запускаете команды DML или DDL и, когда они выполнены, запускаете инструкции COMMIT или ROLLBACK
                                            
                                            -- Транзакция может содержать только одну команду ROLLBACK, которая выполнит откат всей транзакции и сбросит счетчик @@TRANCOUNT в 0.
 


-- Взаимоблокировки

-- Если следующие два примера выполнять пошагово (Выделять построково код и выполнять), то эти транзакцию вызовут взаимоблокировку. Как итог
-- MSSQL просто завершает одну из транзакций с ошибкой 1205, соответственно блокировка снимается и другая транзакция продолжает выполенение.
-- 1)
-- USE TSQLV4;
-- BEGIN TRAN;

-- UPDATE HR.Employees          -- обновляем и блокируем эту строку
-- SET Region = N'10004'
-- WHERE empid = 1

-- UPDATE Production.Suppliers  -- эта строка заблокирвоана второй транзакцией
-- SET Fax = N'555-1212'
-- WHERE supplierid = 1

-- IF @@TRANCOUNT > 0 ROLLBACK

-- 2)
-- USE TSQLV4;
-- BEGIN TRAN;

-- UPDATE Production.Suppliers  -- обновляем и блокируем эту строку
-- SET Fax = N'555-1212'
-- WHERE supplierid = 1

-- UPDATE HR.Employees          -- эта строка заблокирована первой транзакцией
-- SET phone = N'555-9999'
-- WHERE empid = 1

-- IF @@TRANCOUNT > 0 ROLLBACK





 -- Уровни изоляции транзакций:

-- READ COMMITTED. Это уровень изоляции по умолчанию. Все модули чтения в данном сеансе будут только выполнять чтение изменений данных, которые были
-- зафиксированы. Поэтому все инструкции SELECT будут пытаться получить совмещаемые блокировки, и любые базовые ресурсы данных, которые изменяются
-- в разных сеансах и, следовательно, имеют монопольные блокировки, будут блокировать сеанс READ COMMITTED.
-- Короче говоря, если SELECT читает даннные, которые в данный момент изменяются - SELECT будет заблокирован и будет ожидать, пока транзакция изменения данных не закончится

-- READ UNCOMMMITED. Этот уровень изоляции позволяет модулям чтения читать незафиксированные данные. 
-- Эта настройка удаляет совмещаемые блокировки, полученные инструкциями SELECT, так что модули чтения больше уже не блокируются модулями записи. 
-- Но результаты инструкции SELECT могут считывать незафиксированные данные, которые были изменены в течение транзакции и
-- позже откатывались к их первоначальному состоянию. Это называется "грязным" чтением данных. 
-- Короче говоря, если SELECT читает даннные, которые в данный момент изменяются - SELECT НЕ будет заблокирован, он может прочитать частично измененные, а частично
-- неизмененные данные.

-- READ COMMITTED SNAPSHOT. Фактически это не новый уровень изоляции; это дополнительный способ использования уровня изоляции по умолчанию READ
-- COMMITTED, уровень изоляции по умолчанию в базе данных Windows Azure SQL.
-- Часто называемый сокращенно RCSI, он использует базу данных tempdb для
-- сохранения исходных версий измененных данных. Эти версии хранятся ровно столько, сколько они необходимы, чтобы позволить модулям чтения (т. е.
-- инструкциям SELECT) читать базовые данные в их исходном состоянии.
-- В результате инструкциям SELECT больше не нужны совмещаемые блокировки на базовом ресурсе при выполнении чтения зафиксированных данных. 
-- Короче говоря, если SELECT собирается прочитать данные, которые изменяются, он прочитает данные в том состояниии, в котором они были ДО начала транзакции изменения,
-- следовательно блокироваться этот SELECT не будет, просто прочитает данные до обновления.


-- Редко используемые уровни изоляции:

-- REPEATABLE READ. Этот уровень изоляции, также устанавливаемый на уровне сеанса, гарантирует, что данные, считанные в транзакции, могут быть позднее
-- снова прочитаны в транзакции. Не допускаются операции обновления и удаления уже выбранных строк. 
-- В результате совмещаемые блокировки удерживаются до конца транзакции. Однако транзакция может видеть новые строки, добавленные после первой 
-- операции чтения; это называется фантомным чтением.

-- SNAPSHOT. Этот уровень изоляции также использует управление версиями строк
-- в базе данных tempdb (как это делает RCSI). Он разрешен как постоянное свойство базы данных и поэтому устанавливается на отдельную транзакцию. Транзакция, 
-- использующая уровень изоляции SNAPSHOT, сможет повторить любую операцию чтения, и при этом она не будет видеть никаких фантомных чтений. 
-- Новые строки могут быть добавлены в таблицу, но транзакция не будет их видеть.
-- Поскольку она использует управление версиями строк, уровень изоляции SNAPSHOT не требует совмещаемых блокировок на базовых данных.

-- SERIALIZABLE. Этот уровень изоляции является наиболее строгим и устанавливается на сеанс. На этом уровне все операции чтения являются повторяемыми,
-- и новые строки не разрешены в базовых таблицах, что может удовлетворять условиям инструкций SELECT в транзакции. 